#!/usr/bin/python3

### REFERENCES ###
# https://gitlab.steamos.cloud/steamrt/steam-runtime-tools/-/blob/master/docs/steam-compat-tool-interface.md
# https://www.dosbox.com/wiki/Dosbox.conf
# https://www.dosbox.com/DOSBoxManual.html
# https://www.dosbox.com/wiki/MOUNT
# https://github.com/dosbox-staging/dosbox-staging/wiki/Config-file-examples
# https://www.doomworld.com/forum/topic/127408-setting-up-dosbox-properly/
# https://docs.python.org/3/howto/argparse.html
# https://docs.python.org/3/library/argparse.html
# readme template : https://github.com/othneildrew/Best-README-Template/blob/master/README.md
# https://numpydoc.readthedocs.io/en/latest/example.html#example

import sys
import os
import configparser
import shlex
import argparse
from pathlib import Path

DEBUG = True
HOME = os.path.expanduser("~")
STEAM_APP_ID = str(os.environ.get("STEAM_COMPAT_APP_ID")) 
STEAM_GAME_INSTALL_PATH = str(os.environ.get("STEAM_COMPAT_INSTALL_PATH"))
STEAM_INSTALL_PATH = str(os.environ.get("STEAM_COMPAT_CLIENT_INSTALL_PATH"))
SCRIPT_PATH = str(os.path.dirname(__file__))
DOSBOX = 'io.github.dosbox-staging'

debugLog = SCRIPT_PATH + '/debug/debug_' + STEAM_APP_ID + '.log'
autoConfigPath = STEAM_GAME_INSTALL_PATH + '/HazeCrate_AUTO_' + STEAM_APP_ID + '.conf'

if os.path.exists(autoConfigPath):
    os.remove(autoConfigPath)

if os.path.exists(debugLog):
    os.remove(debugLog)

def writeDebugLine(line):
    if(DEBUG):
        with open(debugLog, 'a') as f:
            f.write(line + '\n')

def writeNewConfigLine(line):
    try:
        with open(autoConfigPath, 'a') as f:
            f.write(line + '\n')
    except Exception as e:
        writeDebugLine("Can't save config: " + autoConfigPath + "Exception: " + str(e))

def file_exists_ci(file):
    # If the file doesn't exist in the case specified, loop through every file in the specified directory
    if not os.path.exists(file):
        if '/' in file:
            dir = os.path.dirname(file)
        else:
            dir = './'
        for f in os.listdir(dir):
            # What if the current file and the file we are looking for were both lower case, would they match then?
            if str(f).lower() == str(os.path.basename(file)).lower():
                return str(os.path.join(dir, f))
        # No config found? Return false?
        return ''
    else:
        # Yeah that file is right here dude
        return str(file)

def getDOSBoxConfPath(path):
    if not STEAM_GAME_INSTALL_PATH in path:
        path = STEAM_GAME_INSTALL_PATH + '/' + path
    dosboxConfPath = file_exists_ci(path)

    return dosboxConfPath

def getSectionAutoexec(conf):
    autoexecConf = []

    # Find the [autoexec] section
    for line in conf:
        #writeDebugLine(line)
        # If the current line is the [autoexec] header, if we've already found it, and that the line isn't empty
        if(line.lower() == '[autoexec]' or autoexecConf) and line:
            # Stop if we find another section header
            if(line[0] == '[' and line.lower() != '[autoexec]'):
                #writeDebugLine("End autoexec")
                break
            autoexecConf.append(line)

    # The [autoexec] sections can be an absolute mess, let's try to clean it up.
    for i in range(len(autoexecConf)):
        line = autoexecConf[i]
        # Fix the paths for a Linux environment
        autoexecConf[i] = autoexecConf[i].replace('\\','/')

        # Try to fix the case senstitivity in mount lines...
        if autoexecConf[i].lower().startswith('mount'):
            autoexecConf[i] = parseConfigMountCommand(autoexecConf[i])

        # Try to fix the case senstitivity in imgmount lines...
        if autoexecConf[i].lower().startswith('imgmount'):
            autoexecConf[i] = parseConfigImgmountCommand(autoexecConf[i])
    return autoexecConf

def parseConfigMountCommand(line):
    args = shlex.split(line)
    args[2] = validateMountPath(args[2])
    line = ' '.join(args)
    return line

def parseConfigImgmountCommand(line):
    args = shlex.split(line)
    for i in range(len(args)):
        if str(args[i]).replace('"', '').lower().endswith('.iso'):
            args[i] = validateMountPath(args[i])
    line = ' '.join(args)
    return line

def validateMountPath(path):
    writeDebugLine("Intial Path: " + path)
    pathDirs = (path.replace('"', '')).split('/')
    dir = os.getcwd()
    for d in pathDirs:
        dir = dir + '/' + d
        searchPath = Path(dir)
        dir = file_exists_ci(str(searchPath.resolve()))
    newPath = str(Path(dir).resolve())
    newPath = newPath.replace(str(HOME), '~')
    newPath =  '"' + newPath + '"'
    writeDebugLine("Updated Path: " + newPath)
    return newPath

def parseArgs(args):
    """
    for i in range(len(args)):
        if " " in args[i]:
            args[i] = args[i].strip('"')
            args[i] = args[i].strip("'")
            args[i] = '"' + args[i] + '"'
            args[i] = args[i].replace(' ','')
    """
    writeDebugLine('Arguments ' + str(args))
    argParser = argparse.ArgumentParser()
    argParser.add_argument('steampath', nargs='?', default='')
    argParser.add_argument('--dosbox', default='')
    argParser.add_argument('name', nargs='?', default='')
    argParser.add_argument('-conf', help='DOSBox configuration file.', default='/dosbox.conf')
    argParser.add_argument('-exit', action='store_true')
    argParser.add_argument('-c')
    argParser.add_argument('-fullscreen', action='store_true')
    argParser.add_argument('-lang')
    argParser.add_argument('-machine')
    argParser.add_argument('-noconsole', action='store_true')
    argParser.add_argument('-startmapper', action='store_true')
    argParser.add_argument('-noautoexec', action='store_true')
    argParser.add_argument('-securemode', action='store_true')
    argParser.add_argument('-scaler')
    argParser.add_argument('-forcescaler')
    argParser.add_argument('-version', action='store_true')
    argParser.add_argument('-socket')
    argParser.add_argument('-editconf')
    argParser.add_argument('-opencaptures')
    argParser.add_argument('-printconf', action='store_true')
    argParser.add_argument('-eraseconf', action='store_true')
    argParser.add_argument('-erasemapper')
    try:
        writeDebugLine("trying to parse args")
        results = argParser.parse_args(args)
    except Exception as e:
        writeDebugLine('Error parsing arguments ' + str(args))
        writeDebugLine('Exception: ' + str(e))
    """
    writeDebugLine ("Arguments")
    for k in results.__dict__:
        writeDebugLine(str(k) + ', ' + str(results.__dict__[k]))
    """   
    return results

def newDosboxCommand(args):
    command = []
    # flatpak run and set filesystem path
    #command.append("flatpak run --filesystem=" + shlex.quote('~' + STEAM_GAME_INSTALL_PATH[len(HOME):]))

    # Need access to Steam games and script directory
    # https://docs.flatpak.org/en/latest/sandbox-permissions.html
    command.append('flatpak run --filesystem="' + SCRIPT_PATH + '" --filesystem="' + STEAM_INSTALL_PATH + '"')

    # DOSBox flatpak to use
    command.append(DOSBOX)
    # Executable if it was listed
    if (args.name):
        exePath = STEAM_GAME_INSTALL_PATH + '/' + (args.name).replace('\\','/')
        exePath = file_exists_ci(exePath)
        command.append(shlex.quote(exePath))
    # New DOSBox config
    command.append("-conf")
    command.append(shlex.quote(autoConfigPath))
    # Make sure we exit DOSBox when the game exits
    command.append("-exit")
    # Create command string from array
    cmdString = str(" ".join(command))

    return(cmdString)

def getDosboxConfGlobalTemplate():
    # DOSBOX configuration template to override for settings better for Steam Deck
    path = os.path.dirname(__file__) + '/global_dosbox.conf'
    with open(path, 'r') as file:
        lines = file.read()

    return(lines)

def getConfigPath(conf):
    # Let's find the dosbox config file!
    if conf:
        writeDebugLine('DOSBox config found: ' + conf)
        path = getDOSBoxConfPath(os.getcwd() + '/' + str(conf).replace('\\','/'))
    else:
        writeDebugLine('No config found. Is this even a DOSBox game?')

    return path

def getConfigData(path):
    try:
        with open(path, 'r') as file:
            lines = file.read().splitlines()
    except Exception as e:
        writeDebugLine("Couldn't open config. Exception: " + str(e))

    return lines

def UpdateConfig(path):
    config = configparser.ConfigParser()
    configData = getConfigData(path)
    autoexec = getSectionAutoexec(configData)
    # Parse the config file
    try:
        config.read(path)
    # Usually exceptions are [autoexec] errors since configParser doesn't like the format.
    except Exception as e:
        writeDebugLine("Couldn't parse config. Exception: " + str(e))

    ### Apply Steam Deck config template ###
    templateDosboxConf = getDosboxConfGlobalTemplate()
    config.read_string(templateDosboxConf)

    # Delete the [autoexec] section. We handle it separately
    config.remove_section('autoexec')

    # Save modified config
    for section in config.sections():
        writeNewConfigLine('[' + section + ']')
        for (key, val) in config.items(section):
            writeNewConfigLine(key + '=' + val)

    # Save [autoexec] section
    for line in autoexec:
        #writeDebugLine('written autoexec: ' + line)
        writeNewConfigLine(line)

def main():
    writeDebugLine('APP ID: ' + STEAM_APP_ID)
    writeDebugLine('INSTALL PATH: ' + STEAM_GAME_INSTALL_PATH)
    writeDebugLine('HAZECRATE PATH: ' + SCRIPT_PATH)  
    writeDebugLine('Args: ' + str(sys.argv))

    args = parseArgs(sys.argv)
    configPath = getConfigPath(args.conf)
    UpdateConfig(configPath)
    cmd = newDosboxCommand(args)
    writeDebugLine('CMD: ' + cmd)
    os.system(cmd)

if __name__ == "__main__":
    main()
