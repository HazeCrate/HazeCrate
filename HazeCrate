#!/usr/bin/python3

### REFERENCES ###
# https://gitlab.steamos.cloud/steamrt/steam-runtime-tools/-/blob/master/docs/steam-compat-tool-interface.md
# https://www.dosbox.com/wiki/Dosbox.conf
# https://www.dosbox.com/DOSBoxManual.html
# https://www.dosbox.com/wiki/MOUNT
# https://github.com/dosbox-staging/dosbox-staging/wiki/Config-file-examples
# https://www.doomworld.com/forum/topic/127408-setting-up-dosbox-properly/
# https://docs.python.org/3/howto/argparse.html
# https://docs.python.org/3/library/argparse.html
# readme template : https://github.com/othneildrew/Best-README-Template/blob/master/README.md
# https://numpydoc.readthedocs.io/en/latest/example.html#example

import sys
import os
import configparser
import shlex
import argparse
from pathlib import Path

DEBUG = True
HOME = os.path.expanduser("~")
STEAM_COMPAT_APP_ID = str(os.environ.get("STEAM_COMPAT_APP_ID")) 
STEAM_COMPAT_INSTALL_PATH = str(os.environ.get("STEAM_COMPAT_INSTALL_PATH"))
DOSBOX = 'io.github.dosbox-staging'

debugLog = '/home/deck/.steam/steam/compatibilitytools.d/HazeCrate/debug/debug_' + STEAM_COMPAT_APP_ID + '.log'
autoConfigPath = STEAM_COMPAT_INSTALL_PATH + '/HazeCrate_AUTO_' + STEAM_COMPAT_APP_ID + '.conf'

if os.path.exists(autoConfigPath):
    os.remove(autoConfigPath)

if os.path.exists(debugLog):
    os.remove(debugLog)

def writeDebugLine(line):
    if(DEBUG):
        with open(debugLog, 'a') as f:
            f.write(line + '\n')

def writeNewConfigLine(line):
    try:
        with open(autoConfigPath, 'a') as f:
            f.write(line + '\n')
    except Exception as e:
        writeDebugLine("Can't save config: " + autoConfigPath + "Exception: " + str(e))

def file_exists_ci(file):
    # If the file doesn't exist in the case specified, loop through every file in the specified directory
    if not os.path.exists(file):
        if '/' in file:
            dir = os.path.dirname(file)
        else:
            dir = './'
        for f in os.listdir(dir):
            # What if the current file and the file we are looking for were both lower case, would they match then?
            if str(f).lower() == str(os.path.basename(file)).lower():
                return str(os.path.join(dir, f))
        # No config found? Return false?
        return ''
    else:
        # Yeah that file is right here dude
        return str(file)

def getDOSBoxConfPath(path):
    if not STEAM_COMPAT_INSTALL_PATH in path:
        path = STEAM_COMPAT_INSTALL_PATH + '/' + path
    dosboxConfPath = file_exists_ci(path)

    return dosboxConfPath

def getSectionAutoexec(conf):
    autoexecConf = []

    # Find the [autoexec] section
    for line in conf:
        writeDebugLine(line)
        # If the current line is the [autoexec] header, if we've already found it, and that the line isn't empty
        if(line.lower() == '[autoexec]' or autoexecConf) and line:
            # Stop if we find another section header
            if(line[0] == '[' and line.lower() != '[autoexec]'):
                writeDebugLine("End autoexec")
                break
            autoexecConf.append(line)

    # The [autoexec] sections can be an absolute mess, let's try to clean it up.
    for i in range(len(autoexecConf)):
        line = autoexecConf[i]
        # Fix the paths for a Linux environment
        autoexecConf[i] = autoexecConf[i].replace('\\','/')

        # Try to fix the case senstitivity in mount lines...
        if autoexecConf[i].lower().startswith('mount'):
            autoexecConf[i] = parseConfigMountCommand(autoexecConf[i])

        # Try to fix the case senstitivity in imgmount lines...
        if autoexecConf[i].lower().startswith('imgmount'):
            autoexecConf[i] = parseConfigImgmountCommand(autoexecConf[i])
    return autoexecConf


def parseConfigMountCommand(line):
    mountArgs = shlex.split(line)
    driveLetter = mountArgs[1]
    localDir = mountArgs[2]
    localDir = localDir.replace('"', '')
    localDirPathArray = localDir.split('/')
    localDirPath = os.getcwd()
    for d in localDirPathArray:
        path = str(localDirPath + '/' + d)
        searchPath = Path(path)
        localDirPath = file_exists_ci(str(searchPath.resolve()))
    path = Path(localDirPath)
    writeDebugLine("LocalDirPath: " + localDirPath)
    writeDebugLine("LocalDirPath, Resolved: " + str(path.resolve()))
    if str(localDirPath).startswith(str(HOME + '/')):
        localDirPath = "~/" + localDirPath[len(HOME) + 1:]
    writeDebugLine("LocalDirPath, Final: " + localDirPath)
    mountArgs[2] = localDirPath
    if localDirPath == '':
        mountArgs[2] = './'
        writeDebugLine('No local dir path: ./')
    mountArgs[2] = '"' + mountArgs[2] + '"'
    line = ' '.join(mountArgs)
    writeDebugLine("Mount line (fixed): " + line)

    return line

# Harvester
# imgmount D -t iso "..\HARVEST_CD\HARVESTER_DISC1.ISO" "..\HARVEST_CD\HARVESTER_DISC2.ISO" "..\HARVEST_CD\HARVESTER_DISC3.ISO"
# doc example
# imgmount d c:\mr2_cd1.iso c:\mr2_cd2.iso -t iso
def parseConfigImgmountCommand(line):
    writeDebugLine('imgmount line: ' + line)
    result = ''
    args = shlex.split(line)
    driveLetter = args[1]
    for i in range(len(args)):
        if str(args[i]).replace('"', '').lower().endswith('.iso'):
            path = Path(args[i])
            writeDebugLine("ISO: " + file_exists_ci(args[i]))
            writeDebugLine("ISO, resolved: " + str(path.resolve()))
            args[i] = '"' + str(path.resolve()) + '"'

        args[i] = args[i].replace(str(HOME), '~')

    result = ' '.join(args)
    writeDebugLine('New imgmount line: ' + result)
    #result = line
    return result

def validateMountPath(path):
    validPath = path
    return validPath

def parseArgs(args):
    argParser = argparse.ArgumentParser()
    argParser.add_argument('steampath', nargs='?', default='')
    argParser.add_argument('--dosbox', default='')
    argParser.add_argument('name', nargs='?', default='')
    argParser.add_argument('-conf', help='DOSBox configuration file.', default='/dosbox.conf')
    argParser.add_argument('-exit', action='store_true')
    argParser.add_argument('-c')
    argParser.add_argument('-fullscreen', action='store_true')
    argParser.add_argument('-lang')
    argParser.add_argument('-machine')
    argParser.add_argument('-noconsole', action='store_true')
    argParser.add_argument('-startmapper', action='store_true')
    argParser.add_argument('-noautoexec', action='store_true')
    argParser.add_argument('-securemode', action='store_true')
    argParser.add_argument('-scaler')
    argParser.add_argument('-forcescaler')
    argParser.add_argument('-version', action='store_true')
    argParser.add_argument('-socket')
    argParser.add_argument('-editconf')
    argParser.add_argument('-opencaptures')
    argParser.add_argument('-printconf', action='store_true')
    argParser.add_argument('-eraseconf', action='store_true')
    argParser.add_argument('-erasemapper')
    try:
        results = argParser.parse_args(args)
    except Exception as e:
        writeDebugLine('Error parsing arguments ' + str(args))
        writeDebugLine('Exception: ' + str(e))
    writeDebugLine ("Arguments")
    for k in results.__dict__:
        writeDebugLine(str(k) + ', ' + str(results.__dict__[k]))

    return results

def newDosboxCommand(args):
    command = []
    # flatpak run and set filesystem path
    #command.append("flatpak run --filesystem=" + shlex.quote('~' + STEAM_COMPAT_INSTALL_PATH[len(HOME):]))

    # Need access to Steam games and script directory
    # https://docs.flatpak.org/en/latest/sandbox-permissions.html
    command.append("flatpak run --filesystem=~/.steam/steam/compatibilitytools.d/HazeCrate/ --filesystem=~/.local/share/Steam/")

    # DOSBox flatpak to use
    command.append(DOSBOX)
    # Executable if it was listed
    if (args.name):
        exePath = STEAM_COMPAT_INSTALL_PATH + '/' + (args.name).replace('\\','/')
        exePath = file_exists_ci(exePath)
        command.append(shlex.quote(exePath))
    # New DOSBox config
    command.append("-conf")
    command.append(shlex.quote(autoConfigPath))
    # Make sure we exit DOSBox when the game exits
    command.append("-exit")
    # Create command string from array
    cmdString = str(" ".join(command))

    return(cmdString)

def getDosboxConfGlobalTemplate():
    # DOSBOX configuration template to override for settings better for Steam Deck
    path = os.path.dirname(__file__) + '/global_dosbox.conf'
    with open(path, 'r') as file:
        lines = file.read()

    return(lines)

def getConfigPath(conf):
    # Let's find the dosbox config file!
    if conf:
        writeDebugLine('DOSBox config found: ' + conf)
        path = getDOSBoxConfPath(os.getcwd() + '/' + str(conf).replace('\\','/'))
    else:
        writeDebugLine('No config found. Is this even a DOSBox game?')

    return path

def getConfigData(path):
    try:
        with open(path, 'r') as file:
            lines = file.read().splitlines()
    except Exception as e:
        writeDebugLine("Couldn't open config. Exception: " + str(e))

    return lines

def UpdateConfig(path):
    config = configparser.ConfigParser()
    configData = getConfigData(path)
    autoexec = getSectionAutoexec(configData)
    # Parse the config file
    try:
        config.read(path)
    # Usually exceptions are [autoexec] errors since configParser doesn't like the format.
    except Exception as e:
        writeDebugLine("Couldn't parse config. Exception: " + str(e))

    ### Apply Steam Deck config template ###
    templateDosboxConf = getDosboxConfGlobalTemplate()
    config.read_string(templateDosboxConf)

    # Delete the [autoexec] section. We handle it separately
    config.remove_section('autoexec')

    # Save modified config
    for section in config.sections():
        writeNewConfigLine('[' + section + ']')
        for (key, val) in config.items(section):
            writeNewConfigLine(key + '=' + val)

    # Save [autoexec] section
    for line in autoexec:
        writeDebugLine('written autoexec: ' + line)
        writeNewConfigLine(line)

def main():
    writeDebugLine('APP ID: ' + STEAM_COMPAT_APP_ID)
    writeDebugLine('INSTALL PATH: ' + STEAM_COMPAT_INSTALL_PATH)
    writeDebugLine('Args: ' + str(sys.argv))

    args = parseArgs(sys.argv)
    configPath = getConfigPath(args.conf)
    UpdateConfig(configPath)
    cmd = newDosboxCommand(args)
    writeDebugLine('CMD: ' + cmd)
    os.system(cmd)

if __name__ == "__main__":
    main()
